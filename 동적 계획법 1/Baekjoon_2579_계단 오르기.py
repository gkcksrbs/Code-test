# 계단의 개수 입력
n = int(input())
# 각 계단의 점수를 저장할 리스트 생성
lst = []
# 각 계단의 점수 입력
for _ in range(n):
    lst.append(int(input()))
# 계단의 개수가 1일 떄
if n == 1:
    # 결과값 출력
    print(lst[0])
# 계단의 개수가 2일 때
elif n == 2:
    # 결과값 출력
    print(lst[0] + lst[1])
# 계단의 개수가 1과 2가 아닐 때
else:
    # 2차원 DP 테이블 생성 및 초기화(1계단 올라왔을 때 0번째 리스트에, 2계단 올라왔을 때는 1번째 리스트에 저장)
    dp = [[0, 0] for _ in range(n)]
    dp[0][0] = lst[0]
    dp[1][0] = lst[0] + lst[1]
    dp[1][1] = lst[1]
    dp[2][1] = lst[0] + lst[2]
    # 다이나믹 프로그래밍 실행
    for i in range(1, n):
        for j in range(2):
            if dp[i][j] != 0:
                # 전 계단을 1계단 올라왔을 때 다음 계단은 2계단을 올라야만 함
                if j == 0:
                    # 리스트의 범위를 벗어나지 않도록
                    if i+2 <= n-1:
                        # 2계단 오른 해당 리스트 1번째 배열에 최대값 입력
                        dp[i+2][1] = max(dp[i+2][1], dp[i][j] + lst[i+2])
                # 전 계단을 2계단 올라왔을 때 다음 계단을 오를 때 1계단 또는 2계단 올라갈 수 있음
                else:
                    # 리스트의 범위를 벗어나지 않도록
                    if i+1 <= n-1:
                        # 1계단 오른 해당 리스트 0번째 배열에 최대값 입력
                        dp[i+1][0] = max(dp[i+1][0], dp[i][j] + lst[i+1])
                    # 리스트의 범위를 벗어나지 않도록
                    if i+2 <= n-1:
                        # 2계단 오른 해당 리스트 1번째 배열에 최대값 입력
                        dp[i+2][1] = max(dp[i+2][1], dp[i][j] + lst[i+2])
    # 결과값 출력
    print(max(dp[-1]))
